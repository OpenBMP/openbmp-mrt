"""OpenBMP MRT

  Copyright (c) 2013-2016 Cisco Systems, Inc. and others.  All rights reserved.
  This program and the accompanying materials are made available under the
  terms of the Eclipse Public License v1.0 which accompanies this distribution,
  and is available at http://www.eclipse.org/legal/epl-v10.html

  .. moduleauthor:: Tim Evens <tievens@cisco.com>
"""
import socket

from struct import pack

#: Attribute Flags
#:  bit 0 = optional
#:  bit 1 = transitive
#:  bit 2 = partial
#:  bit 3 = extended length (2-octet)
#:  bits 4 - 7 are zero
ATTR_FLAGS_OPT = 0x80
ATTR_FLAGS_TRANS = 0x40
ATTR_FLAGS_PARTIAL = 0x20
ATTR_FLAGS_EXLEN = 0x10

#: Attribute Types
ATTR_TYPE_ORIGIN = pack('!BB', ATTR_FLAGS_TRANS, 1)
ATTR_TYPE_AS_PATH = pack('!BB', ATTR_FLAGS_TRANS | ATTR_FLAGS_EXLEN, 2)
ATTR_TYPE_NEXTHOP = pack('!BB', ATTR_FLAGS_TRANS, 3)
ATTR_TYPE_MED = pack('!BB', ATTR_FLAGS_OPT | ATTR_FLAGS_TRANS, 4)
ATTR_TYPE_LOCAL_PREF = pack('!BB', ATTR_FLAGS_TRANS, 5)
ATTR_TYPE_ATOMIC_AGG = pack('!BB', ATTR_FLAGS_TRANS, 6)
ATTR_TYPE_AGGREGATOR = pack('!BB', ATTR_FLAGS_OPT | ATTR_FLAGS_TRANS, 7)
ATTR_TYPE_COMMUNITIES = pack('!BB',  ATTR_FLAGS_OPT | ATTR_FLAGS_TRANS | ATTR_FLAGS_EXLEN, 8)
ATTR_TYPE_ORIGINATOR_ID = pack('!BB',  ATTR_FLAGS_OPT | ATTR_FLAGS_TRANS, 9)
ATTR_TYPE_CLUSTER_LIST = pack('!BB',  ATTR_FLAGS_OPT | ATTR_FLAGS_TRANS, 10)
ATTR_TYPE_MP_REACH = pack('!BB',  ATTR_FLAGS_OPT, 14)


#: Origin Code
ORIGIN_CODE_IGP = 1
ORIGIN_CODE_EGP = 2
ORIGIN_CODE_INCOMPLETE = 3

#: AS_PATH segment types
AS_PATH_SEG_AS_SET = 1
AS_PATH_SEG_AS_SEQ = 2


def encode_attr_origin(origin):
    """ Encode string origin into a BGP ORIGIN attribute TLV

        :param origin:      String value for the origin

        :return: BGP attribute TLV ready to be written
    """
    origin_code = 0

    if 'egp' in origin:
        origin_code = 1
    elif 'incomplete' in origin:
        origin_code = 2

    return ATTR_TYPE_ORIGIN + pack('!B', 1) + pack('!B', origin_code)


def encode_attr_as_path(as_path):
    """ Encode string AS_PATH into a BGP AS_PATH attribute TLV

        ..note: Always uses 4 octet ASN encoding

        :param as_path:      String delimited list of ASNs (can include AS SET { })

        :return: BGP attribute TLV ready to be written
    """
    as_path_segments = ""

    as_seg_list = []
    enc_segment = pack("B", AS_PATH_SEG_AS_SEQ)

    paths = as_path.strip().split(" ")
    for path in paths:

        if len(path):
            # Start of AS-SET
            if path[0] == '{':

                # If not the ASN first in segment, encode segment and start a new AS-SET segment
                if len(as_seg_list) > 0:
                    # encode current segment
                    enc_segment += pack("B", len(as_seg_list))
                    for asn in as_seg_list:
                        enc_segment += pack("!I", int(asn))

                    as_path_segments += enc_segment

                # new segment
                enc_segment = pack("B", AS_PATH_SEG_AS_SET)
                as_seg_list = []

                # Remove AS-SET character
                if len(path) > 1:
                    path = path[1:]
                else:
                    # If it is the only character, skip to next
                    continue

            # End of AS-SET, encode segment and start a new one for next pass
            elif path[0] == '}':
                # encode current segment
                enc_segment += pack("B", len(as_seg_list))
                for asn in as_seg_list:
                    enc_segment += pack("!I", int(asn))

                as_path_segments += enc_segment

                # new AS-SEQ segment
                enc_segment = pack("B", AS_PATH_SEG_AS_SEQ)
                as_seg_list = []
                continue

            # Append AS to segment
            as_seg_list.append(path)

    # encode final segment
    if len(as_seg_list) > 0:
        enc_segment += pack("B", len(as_seg_list))
        for asn in as_seg_list:
            enc_segment += pack("!I", int(asn))

        as_path_segments += enc_segment

    # encode the attribute tlv for all as path segments
    return ATTR_TYPE_AS_PATH + pack("!H", len(as_path_segments)) + as_path_segments


def encode_attr_nexthop(nexthop):
    """ Encode string nexthop into a BGP NEXTHOP attribute TLV

        This encodes RFC4271 nexthop attribute, not RFC4760/next-hop

        :param nexthop:      String value for the next-hop

        :return: BGP attribute TLV ready to be written
    """
    return ATTR_TYPE_NEXTHOP + pack('!B', 4) + socket.inet_pton(socket.AF_INET, nexthop)


def encode_attr_mp_nexthop(nexthop):
    """ Encode string nexthop into a BGP MP_REACH attribute TLV

        A modified MP_REACH attribute that includes only the next hop info (per MRT RFC6396)
        This includes only the next hop address lenght (1 octet) and the next-hop

        :param nexthop:      String value for the next-hop

        :return: BGP attribute TLV ready to be written
    """
    #
    if ':' in nexthop:
        nh_len = 16
        afi = socket.AF_INET6
    else:
        nh_len = 4
        afi = socket.AF_INET

    return ATTR_TYPE_MP_REACH + pack('!BB', nh_len + 1, nh_len) + socket.inet_pton(afi, nexthop)


def encode_attr_med(value):
    """ Encode string med value into a BGP MED attribute TLV

        :param value:      String value

        :return: BGP attribute TLV ready to be written
    """
    return ATTR_TYPE_MED + pack('!BI', 4, long(value))


def encode_attr_local_pref(value):
    """ Encode string local pref value into a BGP MED attribute TLV

        :param value:      String value

        :return: BGP attribute TLV ready to be written
    """
    return ATTR_TYPE_LOCAL_PREF + pack('!BI', 4, long(value))


def encode_attr_atomic_agg():
    """ Encode atomic aggregate into a BGP ATOMIC AGGREGATE attribute TLV

        :return: BGP attribute TLV ready to be written
    """
    return ATTR_TYPE_ATOMIC_AGG + pack('!B', 0)


def encode_attr_aggregator(aggregator):
    """ Encode string aggregator <asn ip> value into a BGP MED attribute TLV

        ..note: Always uses 4 octet ASN encoding

        :param aggregator:      String value of "<ASN> <IPv4 Router ID>"

        :return: BGP attribute TLV ready to be written
    """
    try:
        (asn, ip) = aggregator.split(" ")

        return ATTR_TYPE_AGGREGATOR + pack('!BI', 8, long(asn)) + socket.inet_pton(socket.AF_INET, ip)
    except:
        return ""


def encode_attr_communities(communities):
    """ Encode string community list into a BGP COMMUNITY attribute TLV

        :param communities:      String space delimited list of communities in the format of nn:nn

        :return: BGP attribute TLV ready to be written
    """
    encode_comm = ''
    try:
        for comm in communities.split(' '):
            (h, l) = comm.split(':')
            encode_comm += pack("!I", int(h) << 16 | int(l))

        return ATTR_TYPE_COMMUNITIES + pack('!H', len(encode_comm)) + encode_comm
    except:
        return ''


def encode_attr_originator_id(originator):
    """ Encode string originator into a BGP ORIGINATOR_ID attribute TLV

        :param originator:      String value for the originator router/bgp id

        :return: BGP attribute TLV ready to be written
    """
    return ATTR_TYPE_ORIGINATOR_ID + pack('!B', 4) + socket.inet_pton(socket.AF_INET, originator)


def encode_attr_cluster_list(cluster_list):
    """ Encode string cluster_list into a BGP CLUSTER_LIST attribute TLV

        :param cluster_list:      String space delimited list of cluster id's

        :return: BGP attribute TLV ready to be written
    """
    encode_cluster_list = ""

    try:
        for cluster_id in cluster_list.split(' '):
            encode_cluster_list += socket.inet_pton(socket.AF_INET, cluster_id)

        return ATTR_TYPE_CLUSTER_LIST + pack('!B', len(encode_cluster_list)) + encode_cluster_list

    except:
        return ''
