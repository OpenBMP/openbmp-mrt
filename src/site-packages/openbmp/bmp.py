"""OpenBMP MRT

  Copyright (c) 2013-2016 Cisco Systems, Inc. and others.  All rights reserved.
  This program and the accompanying materials are made available under the
  terms of the Eclipse Public License v1.0 which accompanies this distribution,
  and is available at http://www.eclipse.org/legal/epl-v10.html

  .. moduleauthor:: Tim Evens <tievens@cisco.com>
"""
import socket

from struct import unpack


def bmp_parse_peerhdr(data):
    """ Parse BMP peer header

    :param data:      BMP raw data - should start at peer header

    :return: dictionary defined as::
            {
                type:       <string; either 'GLOBAL' or 'L3VPN'>,
                dist_id:    <int; 64bit route distinguisher id>,
                addr:       <string, printed form of IP>,
                asn:        <int; asn>,
                bgp_id:     <int; bgp ID>,
                isIPv4:     <bool>,
                isPrePolicy <bool; either pre or post>
                is2ByteASN  <bool; either 2 or 4 byte ASN>
                ts_secs:    <timestamp in unix time>,
                ts_usecs:   <timestamp microseconds>
            }
    """
    hdr = { 'type': None,
            'dist_id': 0,
            'addr': None,
            'asn': 0,
            'bgp_id': 0,
            'isIPv4': True,
            'isPrePolicy': True,
            'is2ByteASN': False,
            'ts_secs': 0,
            'ts_usecs': 0}

    (type, flags, hdr['dist_id']) = unpack('>BBQ', data[:10])

    if type == 0:
        hdr['type'] = 'GLOBAL'
    else:
        hdr['type'] = 'L3VPN'

    if flags & 0x80:  # V flag
        hdr['isIPv4'] = False
    else:
        hdr['isIPv4'] = True

    if flags & 0x40:  # L flag
        hdr['isPrePolicy'] = False
    else:
        hdr['isPrePolicy'] = True

    if flags & 0x20:  # A flag
        hdr['is2ByteASN'] = True
    else:
        hdr['is2ByteASN'] = False

    if hdr['isIPv4']:
        hdr['addr'] = socket.inet_ntop(socket.AF_INET, data[22:26])
    else:
        hdr['addr'] = socket.inet_ntop(socket.AF_INET6, data[10:26])

    (hdr['asn'],) = unpack('>I', data[26:30])

    hdr['bgp_id'] = socket.inet_ntop(socket.AF_INET, data[30:34])

    (hdr['ts_secs'], hdr['ts_usecs']) = unpack('>II', data[34:42])

    return hdr


def bmp_parse_bmphdr(data):
    """ Parse BMP header from message string

    :param data:      RAW BMP message - should start at bmp header

    :return: dictionary defined as::
            {
                version:    <int; version of bmp>,
                length:     <int; bmp message length in bytes not including common header>,
                type:       <string; BMP type of message>,
            }
    """
    hdr = { 'version': None,
            'length': 0,
            'type': None }

    if not data:
        return None

    (hdr['version'],) = unpack('B', data[:1])

    if hdr['version'] == 3:
        (hdr['length'], type) = unpack('>IB', data[1:6])
        hdr['length'] -= 6                  # remove the bytes of the common header

        if type == 0:
            hdr['type'] = 'ROUTE_MON'
        elif type == 1:
            hdr['type'] = 'STATS_REPORT'
        elif type == 2:
            hdr['type'] = 'PEER_DOWN'
        elif type == 3:
            hdr['type'] = 'PEER_UP'
        elif type == 4:
            hdr['type'] = 'INIT'
        elif type == 5:
            hdr['type'] = 'TERM'
        else:
            hdr['type'] = "UNKNOWN=%d" % type

    else:
        self.LOG.error("Unsupported BMP version type of %d, cannot proceed" % hdr['version'])
        return None

    return hdr


def resolveIp(addr):
    """ Resolves an IP address to FQDN.

    :param addr:        IPv4/v6 address to resovle
    :return: FQDN or IP address if FQDN unknown/not found
    """
    try:
        return socket.gethostbyaddr(addr)[0]
    except:
        return addr
