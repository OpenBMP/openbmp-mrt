# -*- coding: utf-8 -*-
"""OpenBMP MRT

  Copyright (c) 2013-2016 Cisco Systems, Inc. and others.  All rights reserved.
  This program and the accompanying materials are made available under the
  terms of the Eclipse Public License v1.0 which accompanies this distribution,
  and is available at http://www.eclipse.org/legal/epl-v10.html

  .. moduleauthor:: Tim Evens <tievens@cisco.com>
"""
import multiprocessing
import socket
import kafka
import kafka.common
import time


from openbmp.mrt_bgp4mp_object import MrtBgpMpObject
from openbmp.logger import init_mp_logger

from openbmp.api.parsed.message import Message
from openbmp.api.parsed.message import MsgBusFields
from openbmp.api.parsed.message import Collector
from openbmp.api.parsed.message import Router
from openbmp.api.parsed.message import Peer

from openbmp.bmp import bmp_parse_bmphdr, bmp_parse_peerhdr



class BMPConsumer(multiprocessing.Process):
    """ OpenBMP consumer

        Consumes openbmp.parsed.collector, openbmp.parsed.router, and openbmp.bmp_raw
        message feeds from Kafka.  Collector and router messages are cached.
    """
    # Memory cache of collectors
    COLLECTORS = {}

    # Memory cache of routers
    ROUTERS = {}

    # Memory cache of peers
    PEERS = {}

    def __init__(self, cfg, mrt_bgp4mp_queue, log_queue):
        """ Constructor

            :param cfg:               Configuration dictionary
            :param mrt_bgp4mp_queue:  Output for MRT BGP4MP type
            :param log_queue:         Logging queue - sync logging
        """
        multiprocessing.Process.__init__(self)
        self._stop = multiprocessing.Event()

        self._cfg = cfg
        self._bgp4mp_queue = mrt_bgp4mp_queue
        self._log_queue = log_queue
        self.LOG = None

    def run(self):
        """ Override """
        self.LOG = init_mp_logger("bmp_consumer", self._log_queue)

        # Enable to topics/feeds
        topics = ['openbmp.parsed.collector', 'openbmp.parsed.router', 'openbmp.parsed.peer', 'openbmp.bmp_raw']

        self.LOG.info("Running bmp_consumer")

        # wait for config to load
        while not self.stopped():
            if self._cfg and 'kafka' in self._cfg:
                break


        try:
            # connect and bind to topics
            self.LOG.info("Connecting to %s ... takes a minute to load offsets and topics, please wait" % self._cfg['kafka']['servers'])
            consumer = kafka.KafkaConsumer(*topics,
                                           bootstrap_servers=self._cfg['kafka']['servers'],
                                           client_id=self._cfg['kafka']['client_id'] + '-' + socket.gethostname(),
                                           socket_timeout_ms=5000,
                                           fetch_message_max_bytes=5000000,
                                           group_id=self._cfg['kafka']['group_id'],
                                           auto_commit_enable=True,
                                           auto_commit_interval_ms=1000,
                                           auto_offset_reset='largest' if
                                                            self._cfg['kafka']['offset_reset_largest'] else "smallest")

            self.LOG.info("Connected, now consuming")

            prev_ts = time.time()

            # Loop till stopped
            while not self.stopped():

                # Read messages
                for m in consumer.fetch_messages():
                    if self.stopped():
                        break

                    self.process_msg(m)
                    consumer.task_done(m)

        except kafka.common.KafkaUnavailableError as err:
            self.LOG.error("Kafka Error: %s" % str(err))

        except KeyboardInterrupt:
            pass

        self.LOG.info("consumer stopped")

    def stop(self):
        self._stop.set()

    def stopped(self):
        return self._stop.is_set()

    def process_msg(self, msg):
        """ Process the message

            :param msg:     Message consumed
        """

        m = Message(msg.value)  # Gets body of kafka message.

        if msg.topic == 'openbmp.parsed.collector':
            self.process_collector_msg(m)

        elif msg.topic == 'openbmp.parsed.router':
            self.process_router_msg(m)

        elif msg.topic == 'openbmp.parsed.peer':
            self.process_peer_msg(m)

        elif msg.topic == 'openbmp.bmp_raw':
            self.process_bmp_raw_msg(m)

    def process_collector_msg(self, msg):
        """ Process collector message and cache info for use later

            :param msg:      Message object
        """
        obj = Collector(msg)

        map_list = obj.getRowMap()

        for row in map_list:
            if len(row):
                try:
                    self.LOG.debug("collector: %s [%s]", row[MsgBusFields.ADMIN_ID.getName()], row[MsgBusFields.ACTION.getName()])

                    if row[MsgBusFields.ACTION.getName()] in ('started', 'heartbeat', 'change'):

                        # Update collector hash/cache
                        if row[MsgBusFields.HASH.getName()] not in self.COLLECTORS:
                            self.COLLECTORS[row[MsgBusFields.HASH.getName()]] = {'admin_id': row[MsgBusFields.ADMIN_ID.getName()]}

                    else:
                        self.COLLECTORS.pop(row[MsgBusFields.HASH.getName()], None)

                except:
                    pass

    def process_router_msg(self, msg):
        """ Process Router message

            :param msg:      Message object
        """
        obj = Router(msg)

        map_list = obj.getRowMap()

        # Log messages
        for row in map_list:
            if len(row):
                try:
                    self.LOG.info("router: [%s] %s %s", row['action'],
                                  row['name'], row['ip_address'])

                    if row['action'] in ('first', 'init'):
                        # Update the router hash/cache
                        if row['hash'] not in self.ROUTERS:
                            self.ROUTERS[row['hash']] = {'ip': msg.getRouterIp(), 'name': row['name']}
                    # else:
                    #     self.ROUTERS.pop(row['hash'], None)

                except:
                    self.LOG.debug("router parse error")
                    pass

    def process_peer_msg(self, msg):
        """ Process Peer message

            :param msg:      Message object
        """

        obj = Peer(msg)

        map_list = obj.getRowMap()

        # Log messages
        for row in map_list:
            if len(row):
                try:
                    peer_key = row['router_hash'] + '_' + row['remote_bgp_id'] + '_' + row['peer_rd']

                    self.LOG.info("peer: [%s] %s %s", row['action'],
                                  row['name'], row['remote_ip']) # Peer IP address

                    if row['action'] in ('up'):

                        asn_len = 2
                        if ('4 Octet ASN' in row['adv_cap'] and
                            '4 Octet ASN' in row['recv_cap']):
                            asn_len = 4

                        # Update the peer hash/cache
                        if row['hash'] not in self.PEERS:
                            self.PEERS[peer_key] = {'remote_ip': row['remote_ip'],
                                                    'remote_asn': row['remote_asn'],
                                                    'local_ip': row['local_ip'],
                                                    'local_asn': row['local_asn'],
                                                    'asn_len': asn_len,
                                                    'rd': row['peer_rd']}
                except:
                    self.LOG.debug("peer parse error")
                    pass

    def process_bmp_raw_msg(self, msg):
        """ Process BMP RAW message

        :param msg:      Message object
        """

        c_hash = msg.getCollector_hash_id() # Collector Hash ID
        r_hash = msg.getRouter_hash_id() # Router Hash ID
        r_ip = msg.getRouterIp() # Router IP address
        data = msg.getContent() # Message data to be consumed (should not contain headers)

        mrt_bgp_msg = MrtBgpMpObject()

        mrt_bgp_msg.COLLECTOR_HASH_ID = c_hash
        mrt_bgp_msg.ROUTER_IP = r_ip

        mrt_bgp_msg.PEER_KEY = ""

        # Parse the BMP header
        bmp_hdrs = bmp_parse_bmphdr(data)

        # Parse the BMP headers
        if bmp_hdrs['type'] in ('ROUTE_MON'):
            peer_hdr = bmp_parse_peerhdr(data[6:])
            msg.BMP_DATA = data[48:]

            msg.PEER_ADDR = peer_hdr['addr']
            msg.PEER_RD = peer_hdr['dist_id']
            msg.PEER_ASN = peer_hdr['asn']
            msg.PEER_BGP_ID = peer_hdr['bgp_id']

            if long(peer_hdr['ts_secs']) == 0:
                msg.TIMESTAMP_SEC = time.time()
            else:
                msg.TIMESTAMP_SEC = peer_hdr['ts_secs']

            msg.TIMESTAMP_USEC = peer_hdr['ts_usecs']

            msg.PEER_KEY = r_hash + '_' + msg.PEER_BGP_ID + '_' + str(msg.PEER_RD)

            if c_hash in self.COLLECTORS:
                msg.COLLECTOR_ADMIN_ID = self.COLLECTORS[c_hash]['admin_id']

            if r_hash in self.ROUTERS:
                msg.ROUTER_NAME = self.ROUTERS[r_hash]['name']

            if msg.PEER_KEY in self.PEERS:
                msg.LOCAL_ADDR = self.PEERS[msg.PEER_KEY]['local_ip']
                msg.LOCAL_ASN = self.PEERS[msg.PEER_KEY]['local_asn']
                msg.PEER_ASN_LENGTH = self.PEERS[msg.PEER_KEY]['asn_len']

            # queue message
            self._bgp4mp_queue.put(msg)

        else:
            self.LOG.debug("BMP message type %r not used" % bmp_hdrs['type'])
