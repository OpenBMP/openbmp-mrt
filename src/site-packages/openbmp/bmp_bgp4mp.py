# -*- coding: utf-8 -*-
# encoding=utf8
"""OpenBMP MRT

  Copyright (c) 2013-2016 Cisco Systems, Inc. and others.  All rights reserved.
  This program and the accompanying materials are made available under the
  terms of the Eclipse Public License v1.0 which accompanies this distribution,
  and is available at http://www.eclipse.org/legal/epl-v10.html

  .. moduleauthor:: Tim Evens <tievens@cisco.com>
"""
import multiprocessing
import socket
import os
import logging

from struct import pack
from openbmp.logger import init_mp_logger
from openbmp.RawTimedRotatingFileHandler import RawTimedRotatingFileHandler

class MrtBgp4MpWriter(multiprocessing.Process):
    """ BMP to MRT BGP4MP writer

        Pops messages from mrt_bgp4mp_queue and writes them to the log file.
        Log file is rotated based on rotation configuration.
    """
    # Hashes to track Loggers
    #     Key = <concat of collector, router, and peer addr>, Value = logger)
    PEER_LOGGERS = {}

    def __init__(self, cfg, mrt_bgp4mp_queue, log_queue):
        """ Constructor

            :param cfg:               Configuration dictionary
            :param mrt_bgp4mp_queue:  Output for BMP raw message forwarding
            :param log_queue:         Logging queue - sync logging
        """
        multiprocessing.Process.__init__(self)
        self._stop = multiprocessing.Event()

        self._cfg = cfg
        self._bgp4mp_queue = mrt_bgp4mp_queue
        self._log_queue = log_queue
        self.LOG = None

        self._sock = None

    def run(self):
        """ Override """
        self.LOG = init_mp_logger("mrt_bgp4mp_writer", self._log_queue)

        self.LOG.info("Running mrt_bgp4mp_writer")

        try:
            # wait for the mapping config to be loaded
            while not self.stopped():
                if self._cfg and 'logging' in self._cfg:
                    break

            # process queue
            while not self.stopped():

                # pop message from queue - block if no messages avail
                msg = self._bgp4mp_queue.get()

                # Process the BMP message
                self.process_msg(msg)

                self.LOG.debug("Received bmp message: %s %s %s", msg.COLLECTOR_ADMIN_ID,
                               msg.ROUTER_IP, msg.ROUTER_NAME)

        except KeyboardInterrupt:
            pass

        self.LOG.info("mrt_bgp4mp_writer stopped")

    def process_msg(self, msg):
        """ Process the queue message

        :param msg:     MrtBgpMpObject class object that was received from the queue

        :return: none
        """
        logger_hash = msg.COLLECTOR_HASH_ID + '_' + msg.ROUTER_IP + '_' + msg.PEER_BGP_ID;

        # Add logger if it doesn't exist
        if logger_hash not in self.PEER_LOGGERS:
            filepath = os.path.join(self._cfg['bgp4mp']['log_dir'],
                                    'COLLECTOR_' + msg.COLLECTOR_HASH_ID,
                                    'ROUTER_' + self.resolveIp(msg.ROUTER_IP),
                                    'PEER_' + self.resolveIp(msg.PEER_BGP_ID))
            try:
                os.makedirs(filepath)
            except:
                pass

            self.PEER_LOGGERS[logger_hash] = self.init_logger('openbmp.mrt.peer.' + logger_hash,
                                                              os.path.join(filepath, 'updates.mrt'))

        # Write/log BGP4MP message
        self.write_msg(logger_hash, msg)

    def write_msg(self, logger_hash, msg):
        """ Writes the BGP4MP message based on the message passed

        :param logger_hash:     Hash/ID used for logger reference
        :param msg:             MrtBgpMpObject class object that was received from the queue
        """
        isIPv4 = True if '.' in msg.PEER_ADDR else False

        # extend common header, but not supported by libbgpdump, so it's not used here
        # 0                   1                   2                   3
        # 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                           Timestamp                           |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |             Type              |            Subtype            |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                             Length                            |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                      Microsecond Timestamp                    |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                      Message... (variable)
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        #mrt_msg = pack("!IHHII", msg.TIMESTAMP_SEC,
        #               17, 4,       # Type is BGP4MP_ET, SubType is BGP4MP_MESSAGE_AS4
        #               12 + (8 if isIPv4 else 32) + len(msg.BMP_DATA),
        #               msg.TIMESTAMP_USEC)

        # 0                   1                   2                   3
        # 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                           Timestamp                           |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |             Type              |            Subtype            |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                             Length                            |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                      Message... (variable)
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        mrt_msg = pack("!IHHI", msg.TIMESTAMP_SEC,
                       16, 4,       # Type is BGP4MP_ET, SubType is BGP4MP_MESSAGE_AS4
                       12 + (8 if isIPv4 else 32) + len(msg.BMP_DATA))

        # Build BGP4MP_MESSAGE_AS4 - https://tools.ietf.org/html/rfc6396#section-4.4.3
        #          0                   1                   2                   3
        #  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                         Peer AS Number                        |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                         Local AS Number                       |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |        Interface Index        |        Address Family         |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                      Peer IP Address (variable)               |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                      Local IP Address (variable)              |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                    BGP Message... (variable)
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        mrt_msg += pack("!II", msg.PEER_ASN, msg.LOCAL_ASN)

        mrt_msg += pack("!H", 0)           # Index - currently always zero

        mrt_msg += pack("!H", 1 if isIPv4 else 2)  # Address family for peer addresses

        if isIPv4:
            mrt_msg += socket.inet_pton(socket.AF_INET, msg.PEER_ADDR)
            mrt_msg += socket.inet_pton(socket.AF_INET,
                                        "127.0.0.1" if not msg.LOCAL_ADDR else msg.LOCAL_ADDR)

        else:
            mrt_msg += socket.inet_pton(socket.AF_INET6, msg.PEER_ADDR)
            mrt_msg += socket.inet_pton(socket.AF_INET6,
                                        "::1" if not msg.LOCAL_ADDR else msg.LOCAL_ADDR)

        mrt_msg += msg.BMP_DATA

        self.PEER_LOGGERS[logger_hash].info(mrt_msg)

    def stop(self):
        self._stop.set()

    def stopped(self):
        return self._stop.is_set()

    def resolveIp(self, addr):
        """ Resolves an IP address to FQDN.

        :param addr:        IPv4/v6 address to resovle
        :return: FQDN or IP address if FQDN unknown/not found
        """
        try:
            return socket.gethostbyaddr(addr)[0]
        except:
            return addr

    def init_logger(self, name, filename):
        """ Initialize a new logger instance

        :param name:        name of logger
        :param filename:    Filename for the logger

        :return: logger instance
        """
        logger = logging.getLogger(name)

        for h in logger.handlers:
            logger.removeHandler(h)

        handler = RawTimedRotatingFileHandler(
                            filename=filename,
                            when=self._cfg['bgp4mp']['rotate']['when'],
                            interval=self._cfg['bgp4mp']['rotate']['interval'],
                            backupCount=self._cfg['bgp4mp']['rotate']['backupCount'],
                            delay=True)

        # Set the handler so we can remove it
        logger._handler = handler

        logger.addHandler(handler)

        return logger
